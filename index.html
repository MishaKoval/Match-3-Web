<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <!-- Важные мета-теги для кеширования -->
    <meta http-equiv="Cache-Control" content="public, max-age=31536000, immutable">
    
    <!-- Критически важные настройки для мобильных -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>Match3 Game</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #231F20;
        }
        
        #loading-screen {
            position: fixed;
            width: 100%;
            height: 100%;
            background: #231F20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .progress-container {
            width: 80%;
            max-width: 300px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            width: 0%;
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .error-message {
            color: #ff6b6b;
            margin-top: 20px;
            text-align: center;
            max-width: 80%;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,0,0,0.1);
            border-radius: 5px;
            display: none;
        }
        
        .retry-button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-text">Инициализация игры...</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div id="loading-details" style="margin-top: 10px; font-size: 12px; color: #888;"></div>
        <div id="error-message" class="error-message"></div>
        <button id="retry-button" class="retry-button" onclick="retryLoading()">Повторить</button>
    </div>
    
    <canvas id="unity-canvas" width=960 height=540 tabindex="-1"></canvas>
    
    <script>
        // ==================== КОНФИГУРАЦИЯ ====================
        const UnityConfig = {
            loaderUrl: 'Build/WebBuild.loader.js',
            dataUrl: 'Build/WebBuild.data.unityweb',
            frameworkUrl: 'Build/WebBuild.framework.js.unityweb',
            codeUrl: 'Build/WebBuild.wasm.unityweb',
            streamingAssetsUrl: 'StreamingAssets',
            companyName: 'MiKo',
            productName: 'Match3TelegrammApp',
            productVersion: '1.0',
            
            // Размеры по умолчанию
            defaultWidth: 960,
            defaultHeight: 540,
            
            // Имена файлов для кеширования
            cacheFiles: [
                'Build/WebBuild.loader.js',
                'Build/WebBuild.data.unityweb',
                'Build/WebBuild.framework.js.unityweb',
                'Build/WebBuild.wasm.unityweb'
            ]
        };
        
        // ==================== ПРОСТОЙ КЕШ НА LOCALSTORAGE ====================
        // Более надежный вариант для Telegram
        
        const SimpleCache = {
            version: '1.0.1',
            prefix: 'unity_cache_',
            
            async set(key, data) {
                try {
                    // Для бинарных данных используем base64
                    let value;
                    if (data instanceof ArrayBuffer) {
                        value = this.arrayBufferToBase64(data);
                        localStorage.setItem(this.prefix + key + '_type', 'binary');
                    } else {
                        value = data;
                        localStorage.setItem(this.prefix + key + '_type', 'text');
                    }
                    
                    localStorage.setItem(this.prefix + key, value);
                    localStorage.setItem(this.prefix + key + '_time', Date.now().toString());
                    return true;
                } catch (e) {
                    console.warn('Cache set failed:', e);
                    return false;
                }
            },
            
            async get(key) {
                try {
                    const data = localStorage.getItem(this.prefix + key);
                    if (!data) return null;
                    
                    const type = localStorage.getItem(this.prefix + key + '_type');
                    if (type === 'binary') {
                        return this.base64ToArrayBuffer(data);
                    }
                    return data;
                } catch (e) {
                    console.warn('Cache get failed:', e);
                    return null;
                }
            },
            
            clear() {
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.startsWith(this.prefix)) {
                        localStorage.removeItem(key);
                    }
                });
            },
            
            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            },
            
            base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
        };
        
        // ==================== ЗАГРУЗЧИК ФАЙЛОВ ====================
        
        class UnityLoader {
            constructor() {
                this.totalFiles = UnityConfig.cacheFiles.length;
                this.loadedFiles = 0;
                this.failedFiles = 0;
                this.useCache = this.checkLocalStorage();
                this.fileCache = {};
            }
            
            checkLocalStorage() {
                try {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    return true;
                } catch (e) {
                    console.warn('localStorage not available, cache disabled');
                    return false;
                }
            }
            
            updateProgress() {
                this.loadedFiles++;
                const percent = (this.loadedFiles / this.totalFiles) * 100;
                document.getElementById('progress-bar').style.width = `${percent}%`;
                document.getElementById('loading-details').textContent = 
                    `Загружено ${this.loadedFiles} из ${this.totalFiles} файлов`;
            }
            
            async loadWithRetry(url, retries = 3) {
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        // Пробуем загрузить из кеша
                        if (this.useCache && attempt === 1) {
                            const cached = await SimpleCache.get(url);
                            if (cached) {
                                console.log(`Loaded from cache: ${url}`);
                                this.fileCache[url] = cached;
                                this.updateProgress();
                                return cached;
                            }
                        }
                        
                        // Загружаем с сервера
                        console.log(`Downloading: ${url} (attempt ${attempt}/${retries})`);
                        const response = await fetch(url + `?t=${Date.now()}`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        let data;
                        if (url.includes('.unityweb') || url.includes('.wasm')) {
                            data = await response.arrayBuffer();
                        } else {
                            data = await response.text();
                        }
                        
                        // Сохраняем в кеш
                        if (this.useCache && data) {
                            await SimpleCache.set(url, data);
                        }
                        
                        this.fileCache[url] = data;
                        this.updateProgress();
                        return data;
                        
                    } catch (error) {
                        console.warn(`Failed to load ${url}, attempt ${attempt}:`, error);
                        
                        if (attempt === retries) {
                            this.failedFiles++;
                            throw error;
                        }
                        
                        // Ждем перед повторной попыткой
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                }
            }
            
            async loadAllFiles() {
                const promises = UnityConfig.cacheFiles.map(async (url) => {
                    try {
                        await this.loadWithRetry(url, 2);
                        return { url, success: true };
                    } catch (error) {
                        console.error(`Failed to load ${url}:`, error);
                        return { url, success: false, error: error.message };
                    }
                });
                
                return await Promise.all(promises);
            }
            
            getFileBlobUrl(url) {
                const data = this.fileCache[url];
                if (!data) return url; // Возвращаем оригинальный URL если нет в кеше
                
                if (data instanceof ArrayBuffer) {
                    return URL.createObjectURL(new Blob([data]));
                }
                return url;
            }
        }
        
        // ==================== ИНИЦИАЛИЗАЦИЯ UNITY ====================
        
        let unityInstance = null;
        let unityLoader = null;
        
        async function initializeUnity() {
            const canvas = document.getElementById('unity-canvas');
            const loadingText = document.getElementById('loading-text');
            const errorMessage = document.getElementById('error-message');
            const retryButton = document.getElementById('retry-button');
            
            // Сбрасываем состояние
            errorMessage.style.display = 'none';
            retryButton.style.display = 'none';
            
            try {
                // 1. Настраиваем canvas для мобильных
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isMobile) {
                    // Используем полный экран
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.position = 'fixed';
                    canvas.style.left = '0';
                    canvas.style.top = '0';
                    
                    // Устанавливаем реальные размеры
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = window.innerWidth * dpr;
                    canvas.height = window.innerHeight * dpr;
                    
                    // Блокируем зум
                    document.addEventListener('touchstart', function(e) {
                        if (e.touches.length > 1) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    document.addEventListener('gesturestart', function(e) {
                        e.preventDefault();
                    });
                } else {
                    canvas.width = UnityConfig.defaultWidth;
                    canvas.height = UnityConfig.defaultHeight;
                    canvas.style.width = UnityConfig.defaultWidth + 'px';
                    canvas.style.height = UnityConfig.defaultHeight + 'px';
                }
                
                // 2. Загружаем файлы
                loadingText.textContent = 'Загрузка игровых файлов...';
                unityLoader = new UnityLoader();
                
                const results = await unityLoader.loadAllFiles();
                
                const failed = results.filter(r => !r.success);
                if (failed.length > 0) {
                    console.warn(`Failed to load ${failed.length} files`);
                    // Продолжаем, если основные файлы загружены
                }
                
                // 3. Загружаем Unity loader
                loadingText.textContent = 'Инициализация игрового движка...';
                
                // Проверяем, загружен ли loader
                if (!unityLoader.fileCache[UnityConfig.loaderUrl]) {
                    await unityLoader.loadWithRetry(UnityConfig.loaderUrl);
                }
                
                // Создаем тег script для loader
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    
                    // Используем кешированную версию если есть
                    if (unityLoader.fileCache[UnityConfig.loaderUrl]) {
                        const blob = new Blob([unityLoader.fileCache[UnityConfig.loaderUrl]], 
                                           { type: 'application/javascript' });
                        script.src = URL.createObjectURL(blob);
                    } else {
                        script.src = UnityConfig.loaderUrl + '?nocache=' + Date.now();
                    }
                    
                    script.onload = () => {
                        if (typeof createUnityInstance !== 'function') {
                            reject(new Error('Unity loader not loaded properly'));
                            return;
                        }
                        
                        // 4. Создаем инстанс Unity с кешированными файлами
                        loadingText.textContent = 'Запуск игры...';
                        
                        createUnityInstance(canvas, {
                            arguments: [],
                            dataUrl: unityLoader.getFileBlobUrl(UnityConfig.dataUrl),
                            frameworkUrl: unityLoader.getFileBlobUrl(UnityConfig.frameworkUrl),
                            codeUrl: unityLoader.getFileBlobUrl(UnityConfig.codeUrl),
                            streamingAssetsUrl: UnityConfig.streamingAssetsUrl,
                            companyName: UnityConfig.companyName,
                            productName: UnityConfig.productName,
                            productVersion: UnityConfig.productVersion,
                            matchWebGLToCanvasSize: true,
                            devicePixelRatio: isMobile ? (window.devicePixelRatio || 1) : 1,
                            showBanner: false
                        }).then(instance => {
                            unityInstance = instance;
                            resolve(instance);
                        }).catch(reject);
                    };
                    
                    script.onerror = () => {
                        reject(new Error('Failed to load Unity loader script'));
                    };
                    
                    document.head.appendChild(script);
                });
                
            } catch (error) {
                console.error('Unity initialization failed:', error);
                
                // Показываем ошибку
                errorMessage.textContent = `Ошибка загрузки: ${error.message || 'Неизвестная ошибка'}`;
                errorMessage.style.display = 'block';
                retryButton.style.display = 'block';
                loadingText.textContent = 'Ошибка загрузки игры';
                
                throw error;
            }
        }
        
        // ==================== ФУНКЦИИ ДЛЯ ПОЛЬЗОВАТЕЛЯ ====================
        
        function retryLoading() {
            // Очищаем кеш при ошибке
            SimpleCache.clear();
            
            // Перезагружаем страницу
            window.location.reload();
        }
        
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.opacity = '0';
            loadingScreen.style.transition = 'opacity 0.5s';
            
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
        
        // ==================== ЗАПУСК ПРИ ЗАГРУЗКЕ ====================
        
        document.addEventListener('DOMContentLoaded', async () => {
            // Инициализация Telegram WebApp
            if (window.Telegram && Telegram.WebApp) {
                try {
                    Telegram.WebApp.ready();
                    Telegram.WebApp.expand();
                    Telegram.WebApp.setHeaderColor('#231F20');
                    Telegram.WebApp.setBackgroundColor('#231F20');
                    
                    // Сохраняем версию WebApp
                    console.log('Telegram WebApp version:', Telegram.WebApp.version);
                } catch (e) {
                    console.warn('Telegram WebApp initialization failed:', e);
                }
            }
            
            try {
                // Запускаем Unity
                await initializeUnity();
                
                // Скрываем экран загрузки
                setTimeout(hideLoadingScreen, 1000);
                
                // Для отладки
                console.log('Unity game loaded successfully');
                
            } catch (error) {
                console.error('Game failed to load:', error);
                
                // Fallback: пробуем загрузить напрямую
                setTimeout(() => {
                    document.getElementById('loading-text').textContent = 'Пробуем альтернативный способ загрузки...';
                    
                    const script = document.createElement('script');
                    script.src = UnityConfig.loaderUrl;
                    script.onload = () => {
                        const canvas = document.getElementById('unity-canvas');
                        createUnityInstance(canvas, {
                            arguments: [],
                            dataUrl: UnityConfig.dataUrl,
                            frameworkUrl: UnityConfig.frameworkUrl,
                            codeUrl: UnityConfig.codeUrl,
                            streamingAssetsUrl: UnityConfig.streamingAssetsUrl,
                            companyName: UnityConfig.companyName,
                            productName: UnityConfig.productName,
                            productVersion: UnityConfig.productVersion
                        }).then(instance => {
                            unityInstance = instance;
                            hideLoadingScreen();
                        });
                    };
                    document.head.appendChild(script);
                }, 3000);
            }
        });
        
        // ==================== ОБРАБОТЧИКИ ОШИБОК ====================
        
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            
            if (e.message && e.message.includes('Unity')) {
                document.getElementById('error-message').textContent = 
                    'Ошибка Unity: ' + e.message;
                document.getElementById('error-message').style.display = 'block';
                document.getElementById('retry-button').style.display = 'block';
            }
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled rejection:', e.reason);
        });
        
        // Помощь при проблемах с памятью
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            window.addEventListener('pagehide', function() {
                if (unityInstance) {
                    unityInstance.Quit();
                }
            });
        }
    </script>
</body>
</html>